class FunctionData:
    functionName = ""
    isStatic = False
    returnType = ""
    def __init__(self, fn, iS, rt):
        self.functionName = fn
        self.isStatic= iS
        self.returnType = rt
    def __eq__(self, other) : 
        return self.__dict__ == other.__dict__

print("===== SML Autohooker =====")
print("Finding raw function definitions... ", end = '')
f = open("data/funcs_raw.txt")
print("found")
out = open("../AutogeneratedHooks.h", 'w')
formatted = open("data/funcs_formatted.txt", 'w')
lines = f.readlines()
print("Found " + str(len(lines)) + " potential functions")
out.write("#pragma once\n\n#include <HookLoader.h>\n\n");
i = 0
classes = {}
rawClassNames = {}

defClasses = []
defStructs = []
defEnums = []
isStaticFunction = False
print("Filtering out unusable functions... ", end = '')
for l in lines:
    #replace uneeded tags
    l = l.replace("public: ", "")
    l = l.replace("protected: ", "")
    l = l.replace("private: ", "")
    #get rid of the the calling convention
    l = l.replace("__cdecl ", "")
    #get rid of the virtual and pointer tags
    l = l.replace("virtual ", "")
    l = l.replace("__ptr64", "", 79)
    #remove consts
    l = l.replace("const", "")
    #format pointers and refs better
    l = l.replace(" * ", "*", 79)
    l = l.replace(" & ", "&", 79)
    l = l.replace(" *", "*", 79)
    l = l.replace(" &", "&", 79)
    #replace void params with empty
    l = l.replace("(void)", "()")

    
    # perform a mass filter to get rid of functions that we can't use
    if (l.find("::") == -1): #filter out the useless dynamic initializer stuff
        continue
    if (l.count("::") != 1): #currently, only 1 level of depth is going to be automatically generated because SuperCoder is lazy
        continue
    if (l.find("std::") != -1): #filter out the standard library code
        continue
    if (l.find("lambda_") != -1): #filter out private lambda functions
        continue
    if (l.find("[thunk]") != -1): #filter out thunks
        continue
    if (l.find("kee::") != -1): #filter out random namespaces that aren't really useful
        continue
    if (l.find("physx::") != -1):
        continue
    if (l.find("rtc::") != -1):
        continue
    if (l.find("cricket::") != -1):
        continue
    if (l.find("mkvparser::") != -1):
        continue
    if (l.find("icu_53::") != -1):
        continue
    if (l.find("OT::") != -1):
        continue
    if (l.find("hb_font_t::") != -1):
        continue
    if (l.find("scoped_refptr") != -1): #filter out whatever shit this is
        continue
    if (l.find("`") != -1): #filter out backticks because they break the code
        continue
    if (l.find("Z_Construct") != -1): #filter out Z Constructs
        continue
    if (l.find("::exec") != -1): #filter out blueprint generated C++ functions
        continue
    l = l[:l.find("\t")] #remove everything that isn't the function definition
    if (l[:l.find("::")].find("<") != -1): #filter out functions that have typnames in the class definition because they're a bitch to work with
        continue
    
    # now that we're done with filtering, we generate class definitions out of the function definitions
    i+=1
    classname = l[:l.find("::")]
    funcname = l[l.find("::")+2:]
    staticFunction = False
    funcReturnType = ""
    fullClassName = "";
    if (classname.rfind(" ") != -1):
        info = classname.split(" ")
        fullClassName = info[len(info)-1] #the last index will always be the class name
        if ("class" in info):
            name = info[info.index("class")+1]
            nameNoPointer = name.replace("*", "")
            nameNoPointer = nameNoPointer.replace("&", "")
            nameNoPointer = nameNoPointer.replace(",", "")
            funcReturnType = name
            if (nameNoPointer not in defClasses):
                defClasses.append(nameNoPointer)
            info.remove(name)
        if ("struct" in info):
            name = info[info.index("struct")+1]
            nameNoPointer = name.replace("*", "")
            nameNoPointer = nameNoPointer.replace("&", "")
            nameNoPointer = nameNoPointer.replace(",", "")
            funcReturnType = name
            if (nameNoPointer not in defStructs):
                defStructs.append(nameNoPointer)
            info.remove(name)
        if ("enum" in info):
            name = info[info.index("enum")+1]
            nameNoPointer = name.replace("*", "")
            nameNoPointer = nameNoPointer.replace("&", "")
            nameNoPointer = nameNoPointer.replace(",", "")
            funcReturnType = name
            if (nameNoPointer not in defEnums):
                defEnums.append(nameNoPointer)
            info.remove(name)
        if ("static" in info):
            name = info[info.index("static")]
            staticFunction = True
            info.remove(name)
    else:
        fullClassName = classname
    #if (fullClassName == ""):
        #do something here

    #print(classname + " :: " + fullClassName)

    if (funcReturnType == ""):
        funcReturnType = "void"

    fnOnly = funcname[:funcname.find("(")]
    fnParams = funcname[funcname.find("("):]
    if (fnOnly.find("<") != -1):
        fnOnly = fnOnly[:fnOnly.find("<")]
        #print(fnOnly)
    fnFull = fnOnly + fnParams
    func = FunctionData(fnFull, staticFunction, funcReturnType)
    if (fullClassName in classes):
        if (fnOnly not in rawClassNames[fullClassName]):
            if (fnOnly != fullClassName): #make sure no constructors are hooked (this will add lots of code complexity)
                classes[fullClassName].append(func)
                rawClassNames[fullClassName].append(fnOnly)
    else:
        rawClassNames[fullClassName] = [fnOnly]
        classes[fullClassName] = [func]
print("done")
print("Found " + str(i) + " usable function definitions")
j = 0;
out.write("//WARNING: This is an autogenerated file! Do not change it manually! Use the autogenerator script instead.\n\n\n")
out.write("namespace SML {\n\tnamespace AutoGenerated {\n\n") # add namespaces
print("Generating classes... ", end = '')
for x in defClasses:
    out.write("\t\tclass " + x + ";\n")
for x in defStructs:
    out.write("\t\tstruct " + x + ";\n")
for x in defEnums:
    out.write("\t\tenum " + x + ";\n")
out.write("\t\t\n\n")
for x in classes:
    out.write("\t\tclass " + x + " {\n")
    out.write("\t\tpublic:\n");
    for y in classes[x]:
        before = ""
        if y.isStatic:
            before += "static "
        before += y.returnType + " "
        out.write(("\t\t\t " + before + y.functionName + ";\n").replace(" ;", ";"))
        formatted.write(x+"::"+y.functionName+"\n") #format the functions as a precursor
        j+=1
    out.write("\t\t};\n\n")
    for y in classes[x]:
        out.write("\t\tDEFINE_METHOD("+x.replace("static ","")+"::"+y.functionName[:y.functionName.find("(")]+");\n")
    out.write("\n")
out.write("\t};\n};") #close namespaces
print("done");
print("Finished printing to data/funcs_formatted.txt")
f.close()
formatted.close()
out.close()
print("SML AutoHooker is finished!")
#input("Press enter to exit.") #uncomment this in non dev env
